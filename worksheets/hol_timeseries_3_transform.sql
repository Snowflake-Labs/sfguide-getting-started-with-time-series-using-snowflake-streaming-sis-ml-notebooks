-- Set role, context, and warehouse
USE ROLE ROLE_HOL_TIMESERIES;
USE HOL_TIMESERIES.TRANSFORM;
USE WAREHOUSE HOL_TRANSFORM_WH;

-- Setup Transform Tabls
-- Sensor metadata (Dimension)
CREATE OR REPLACE TABLE HOL_TIMESERIES.TRANSFORM.TS_TAG_METADATA (
    TAGKEY NUMBER NOT NULL,
    NAMESPACE VARCHAR,
    TAGNAME VARCHAR NOT NULL,
    TAGALIAS ARRAY,
    TAGDESCRIPTION VARCHAR,
    TAGUNITS VARCHAR,
    TAGDATATYPE VARCHAR,
    INGESTION_TIMESTAMP TIMESTAMP_NTZ,
    CONSTRAINT PK_TSD_TAG_METADATA PRIMARY KEY (TAGKEY) RELY
);

-- Sensor readings (Fact)
CREATE OR REPLACE TABLE HOL_TIMESERIES.TRANSFORM.TS_TAG_READINGS (
    TAGKEY NUMBER NOT NULL,
    TS TIMESTAMP_NTZ NOT NULL,
    VAL VARCHAR,
    VAL_NUMERIC FLOAT,
    PARTITION NUMBER,
    OFFSET NUMBER,
    INGESTION_TIMESTAMP TIMESTAMP_NTZ,
    CONSTRAINT FK_TSD_TAG_READINGS FOREIGN KEY (TAGKEY) REFERENCES HOL_TIMESERIES.TRANSFORM.TS_TAG_METADATA (TAGKEY) RELY
);

-- IOT STREAM Load
-- Transform and load raw IOT sensor metadata
INSERT INTO HOL_TIMESERIES.TRANSFORM.TS_TAG_METADATA
WITH NEWTAGS AS (
    SELECT DISTINCT
        SRC.RECORD_METADATA:headers:namespace::VARCHAR AS NAMESPACE,
        UPPER(CONCAT('/', SRC.RECORD_METADATA:headers:namespace::VARCHAR, '/', TRIM(SRC.RECORD_CONTENT:tagname::VARCHAR))) AS TAGNAME,
        SRC.RECORD_METADATA:headers:source::VARCHAR AS TAGDESCRIPTION,
        SRC.RECORD_CONTENT:units::VARCHAR AS TAGUNITS,
        SRC.RECORD_CONTENT:datatype::VARCHAR AS TAGDATATYPE
    FROM HOL_TIMESERIES.STAGING.RAW_TS_IOTSTREAM_DATA SRC
    WHERE NOT EXISTS (
        SELECT 1 FROM HOL_TIMESERIES.TRANSFORM.TS_TAG_METADATA TGT
        WHERE TGT.TAGNAME = UPPER(CONCAT('/', SRC.RECORD_METADATA:headers:namespace::VARCHAR, '/', TRIM(SRC.RECORD_CONTENT:tagname::VARCHAR)))
    )
)
SELECT
    (SELECT ZEROIFNULL(MAX(TAGKEY)) FROM HOL_TIMESERIES.TRANSFORM.TS_TAG_METADATA) + ROW_NUMBER() OVER (PARTITION BY NULL ORDER BY SRC.TAGNAME) AS TAGKEY,
    SRC.NAMESPACE AS NAMESPACE,
    SRC.TAGNAME AS TAGNAME,
    TO_ARRAY(SRC.TAGNAME) AS TAGALIAS,
    SRC.TAGDESCRIPTION AS TAGDESCRIPTION,
    SRC.TAGUNITS,
    SRC.TAGDATATYPE,
    SYSDATE() AS INGESTION_TIMESTAMP
FROM NEWTAGS SRC
ORDER BY TAGKEY, TAGNAME;

-- Transform and load raw IOT sensor Readings
INSERT INTO HOL_TIMESERIES.TRANSFORM.TS_TAG_READINGS
SELECT
    META.TAGKEY,
    SRC.RECORD_CONTENT:timestamp::VARCHAR::TIMESTAMP_NTZ AS TS,
    SRC.RECORD_CONTENT:value::VARCHAR AS VAL,
    TRY_CAST(SRC.RECORD_CONTENT:value::VARCHAR AS FLOAT) AS VAL_NUMERIC,
    SRC.RECORD_METADATA:partition::VARCHAR AS PARTITION,
    SRC.RECORD_METADATA:offset::VARCHAR AS OFFSET,
    SYSDATE() AS INGESTION_TIMESTAMP
FROM HOL_TIMESERIES.STAGING.RAW_TS_IOTSTREAM_DATA SRC
INNER JOIN HOL_TIMESERIES.TRANSFORM.TS_TAG_METADATA META ON META.TAGNAME = UPPER(CONCAT('/', SRC.RECORD_METADATA:headers:namespace::VARCHAR, '/', TRIM(SRC.RECORD_CONTENT:tagname::VARCHAR)))
WHERE NOT EXISTS (
    SELECT 1 FROM HOL_TIMESERIES.TRANSFORM.TS_TAG_READINGS TGT
    WHERE TGT.TAGKEY = META.TAGKEY AND TGT.TS = SRC.RECORD_CONTENT:timestamp::VARCHAR::TIMESTAMP_NTZ
)
QUALIFY ROW_NUMBER() OVER (PARTITION BY META.TAGKEY, SRC.RECORD_CONTENT:timestamp::VARCHAR::TIMESTAMP_NTZ ORDER BY SRC.RECORD_METADATA:offset::VARCHAR DESC) = 1
ORDER BY TAGKEY, TS;

-- Setup loading procedure
CREATE OR REPLACE PROCEDURE HOL_TIMESERIES.TRANSFORM.PROCEDURE_TS_LOAD_READINGS(IN_LOOP_ENABLED NUMBER, IN_LOOP_ITERATIONS NUMBER)
RETURNS VARCHAR
LANGUAGE SQL
COMMENT='Procedure to load IOTSTREAM readings.'
EXECUTE AS OWNER
AS
BEGIN
    IF (IN_LOOP_ENABLED <> 1) THEN
        IN_LOOP_ITERATIONS := 1;
    END IF;

    BEGIN TRANSACTION;
        FOR i IN 1 TO IN_LOOP_ITERATIONS DO
            -- Load IOT TAG Metadata
            INSERT INTO HOL_TIMESERIES.TRANSFORM.TS_TAG_METADATA
            WITH NEWTAGS AS (
                SELECT DISTINCT
                    SRC.RECORD_METADATA:headers:namespace::VARCHAR AS NAMESPACE,
                    UPPER(CONCAT('/', SRC.RECORD_METADATA:headers:namespace::VARCHAR, '/', TRIM(SRC.RECORD_CONTENT:tagname::VARCHAR))) AS TAGNAME,
                    SRC.RECORD_METADATA:headers:source::VARCHAR AS TAGDESCRIPTION,
                    SRC.RECORD_CONTENT:units::VARCHAR AS TAGUNITS,
                    SRC.RECORD_CONTENT:datatype::VARCHAR AS TAGDATATYPE
                FROM HOL_TIMESERIES.STAGING.STREAM_RAW_TS_IOTSTREAM_DATA SRC
                WHERE NOT EXISTS (
                    SELECT 1 FROM HOL_TIMESERIES.TRANSFORM.TS_TAG_METADATA TGT
                    WHERE TGT.TAGNAME = UPPER(CONCAT('/', SRC.RECORD_METADATA:headers:namespace::VARCHAR, '/', TRIM(SRC.RECORD_CONTENT:tagname::VARCHAR)))
                )
            )
            SELECT
                (SELECT ZEROIFNULL(MAX(TAGKEY)) FROM HOL_TIMESERIES.TRANSFORM.TS_TAG_METADATA) + ROW_NUMBER() OVER (PARTITION BY NULL ORDER BY SRC.TAGNAME) AS TAGKEY,
                SRC.NAMESPACE AS NAMESPACE,
                SRC.TAGNAME AS TAGNAME,
                TO_ARRAY(SRC.TAGNAME) AS TAGALIAS,
                SRC.TAGDESCRIPTION AS TAGDESCRIPTION,
                SRC.TAGUNITS,
                SRC.TAGDATATYPE,
                SYSDATE() AS INGESTION_TIMESTAMP
            FROM NEWTAGS SRC
            ORDER BY TAGKEY, TAGNAME;
            
            -- Load IOT Sensor Readings
            INSERT INTO HOL_TIMESERIES.TRANSFORM.TS_TAG_READINGS
            SELECT
                META.TAGKEY,
                SRC.RECORD_CONTENT:timestamp::VARCHAR::TIMESTAMP_NTZ AS TS,
                SRC.RECORD_CONTENT:value::VARCHAR AS VAL,
                TRY_CAST(SRC.RECORD_CONTENT:value::VARCHAR AS FLOAT) AS VAL_NUMERIC,
                SRC.RECORD_METADATA:partition::VARCHAR AS PARTITION,
                SRC.RECORD_METADATA:offset::VARCHAR AS OFFSET,
                SYSDATE() AS INGESTION_TIMESTAMP
            FROM HOL_TIMESERIES.STAGING.STREAM_RAW_TS_IOTSTREAM_DATA SRC
            INNER JOIN HOL_TIMESERIES.TRANSFORM.TS_TAG_METADATA META ON META.TAGNAME = UPPER(CONCAT('/', SRC.RECORD_METADATA:headers:namespace::VARCHAR, '/', TRIM(SRC.RECORD_CONTENT:tagname::VARCHAR)))
            WHERE NOT EXISTS (
                SELECT 1 FROM HOL_TIMESERIES.TRANSFORM.TS_TAG_READINGS TGT
                WHERE TGT.TAGKEY = META.TAGKEY AND TGT.TS = SRC.RECORD_CONTENT:timestamp::VARCHAR::TIMESTAMP_NTZ
            )
            QUALIFY ROW_NUMBER() OVER (PARTITION BY META.TAGKEY, SRC.RECORD_CONTENT:timestamp::VARCHAR::TIMESTAMP_NTZ ORDER BY SRC.RECORD_METADATA:offset::VARCHAR DESC) = 1
            ORDER BY TAGKEY, TS;

            COMMIT;
        
        END FOR;

    RETURN 'SUCCESS';

EXCEPTION
    WHEN STATEMENT_ERROR THEN
        ROLLBACK;
        RETURN OBJECT_CONSTRUCT(
            'error type', 'statement_error',
            'sqlcode', SQLCODE,
            'sqlerrm', SQLERRM,
            'sqlstate', SQLSTATE);

    WHEN EXPRESSION_ERROR THEN
        ROLLBACK;
        RETURN OBJECT_CONSTRUCT(
            'error type', 'expression_error',
            'sqlcode', SQLCODE,
            'sqlerrm', SQLERRM,
            'sqlstate', SQLSTATE);

    WHEN OTHER THEN
        ROLLBACK;
        RETURN OBJECT_CONSTRUCT(
            'error type', 'other error',
            'sqlcode', SQLCODE,
            'sqlerrm', SQLERRM,
            'sqlstate', SQLSTATE);
END;

-- Test Loading Procedure
CALL HOL_TIMESERIES.TRANSFORM.PROCEDURE_TS_LOAD_READINGS(1,10);

-- Setup loading task - run when data is present in stream
CREATE OR REPLACE TASK HOL_TIMESERIES.TRANSFORM.TASK_TS_LOAD_READINGS
WAREHOUSE=HOL_TRANSFORM_WH
SCHEDULE='USING CRON * * * * * UTC'
COMMENT='Task to call IOTSTREAM procedure.'
WHEN SYSTEM$STREAM_HAS_DATA('HOL_TIMESERIES.STAGING.STREAM_RAW_TS_IOTSTREAM_DATA')
AS CALL HOL_TIMESERIES.TRANSFORM.PROCEDURE_TS_LOAD_READINGS(1,100);

-- Enable loading tak
ALTER TASK HOL_TIMESERIES.TRANSFORM.TASK_TS_LOAD_READINGS RESUME;